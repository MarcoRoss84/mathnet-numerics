<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>

// <copyright file="ManagedConvolutionProvider.cs" company="Math.NET">
// Math.NET Numerics, part of the Math.NET Project
// http://numerics.mathdotnet.com
// http://github.com/mathnet/mathnet-numerics
//
// Copyright (c) 2019 Math.NET
//
// Permission is hereby granted, free of charge, to any person
// obtaining a copy of this software and associated documentation
// files (the "Software"), to deal in the Software without
// restriction, including without limitation the rights to use,
// copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the
// Software is furnished to do so, subject to the following
// conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
// OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
// WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
// OTHER DEALINGS IN THE SOFTWARE.
// </copyright>

<# var types = new[] { "float", "double", "Complex", "Complex32" }; #>

using System;
using System.Numerics;
using MathNet.Numerics.Threading;

namespace MathNet.Numerics.Providers.Convolution.ManagedReference
{
    class ManagedConvolutionProvider : IConvolutionProvider
    {

        <# foreach (var type in types) { #>

        public void Conv1D(<#= type #>[] kernel, <#= type #>[] x, int xOffset, <#= type #>[] y, int yOffset, int length)
        {
            CommonParallel.For(0, length, (a, b) => {
                for (int i = a; i < b; i++)
                {
                    var yi = yOffset + i;
                    if (yi < 0 || yi > y.Length)
                    {
                        throw new ArgumentException("Target index beyond the limits of array: " + yi);
                    }
                    <#= type #> v = 0;
                    for (int k = 0; k < kernel.Length; k++)
                    {
                        var xi = xOffset + i - k;
                        if (xi < 0 || xi >= x.Length) continue;
                        v += kernel[k] * x[xi];
                    }
                    y[yi] = v;
                }
            });
        }

        public void Conv2D(<#= type #>[,] kernel, <#= type #>[,] x, Tuple<int, int> xOffset, <#= type #>[,] y, Tuple<int, int> targetShape)
        {
            var length = targetShape.Item1 * targetShape.Item2;
            CommonParallel.For(0, length, (a, b) => {
                for (int i = a; i < b; i++)
                {
                    var yi1 = i / targetShape.Item1;
                    var yi2 = i % targetShape.Item1;

                    if (yi1 < 0 || yi1 > y.GetLength(0))
                    {
                        throw new ArgumentException("Target index beyond the limits of array: " + yi1);
                    }
                    if (yi2 < 0 || yi2 > y.GetLength(1))
                    {
                        throw new ArgumentException("Target index beyond the limits of array: " + yi2);
                    }
                    <#= type #> v = 0;
                    for (int k1 = 0; k1 < kernel.GetLength(0); k1++)
                    {
                        var xi1 = xOffset.Item1 + yi1 - k1;
                        if (xi1 < 0 || xi1 >= x.GetLength(0)) continue;
                        for (int k2 = 0; k2 < kernel.GetLength(1); k2++)
                        {
                            var xi2 = xOffset.Item2 + yi2 - k2;
                            if (xi2 < 0 || xi2 >= x.GetLength(1)) continue;
                            v += kernel[k1, k2] * x[xi1, xi2];
                        }
                    }
                    y[yi1, yi2] = v;
                }
            });
        }

        <# } #>

        public void InitializeVerify()
        {
        }

        public bool IsAvailable()
        {
            return true;
        }

        public void FreeResources()
        {
        }

    }
}
